"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatNumber = exports.safeNumberToString = exports.formatBN = exports.Format = void 0;
const utils_1 = require("ethers/lib/utils");
var Format;
(function (Format) {
    Format["number"] = "number";
    Format["commas"] = "commas";
    Format["short"] = "short";
    Format["hex"] = "hex";
    Format["percent"] = "percent";
})(Format = exports.Format || (exports.Format = {}));
String.prototype.insert = function (index, substr, fillWith) {
    if (index < 0)
        index = this.length + index;
    let filler = "";
    if (index < 0) {
        if (fillWith)
            filler = fillWith.repeat(-index).slice(index);
        index = 0;
    }
    return this.slice(0, index) + substr + filler + this.slice(index);
};
const RANGES = [
    {
        minDecimals: 24,
        symbol: "Y",
    },
    {
        minDecimals: 21,
        symbol: "Z",
    },
    {
        minDecimals: 18,
        symbol: "E",
    },
    {
        minDecimals: 15,
        symbol: "P",
    },
    {
        minDecimals: 12,
        symbol: "T",
    },
    {
        minDecimals: 9,
        symbol: "B",
    },
    {
        minDecimals: 6,
        symbol: "M",
    },
    {
        minDecimals: 4,
        power: 3,
        symbol: "k",
    },
];
const _formatShort = (bn, decimals, formatOptions) => {
    var _a;
    const stringValue = bn.toString();
    const params = RANGES.find((range) => stringValue.length > range.minDecimals + decimals);
    if (params) {
        return (_applyOptions(stringValue.insert(-(((_a = params.power) !== null && _a !== void 0 ? _a : params.minDecimals) + decimals), ".", "0"), formatOptions) + params.symbol);
    }
    if (formatOptions.smallValuesWithComas) {
        return _formatComas(bn, decimals, formatOptions);
    }
    return _applyOptions(stringValue.insert(-decimals, ".", "0"), formatOptions);
};
const _formatComas = (bn, decimals, formatOptions) => {
    const stringValue = decimals ? bn.toString().insert(-decimals, ".", "0") : bn.toString();
    const [wholePart, decimalPart] = stringValue.split(".");
    return _applyOptions(wholePart
        .split("")
        .reduce((formattedNumber, digit, i, arr) => `${formattedNumber}${!i || (arr.length - i) % 3 ? "" : ","}${digit}`, "") + (decimalPart ? "." + decimalPart : ""), formatOptions);
};
const _formatNumber = (bn, decimals, formatOptions) => {
    if (decimals === 0)
        return _applyOptions(bn.toString(), formatOptions);
    return _applyOptions(bn.toString().insert(-decimals, ".", "0"), formatOptions);
};
const _withUnit = (value, unit) => {
    switch (unit) {
        case "$":
            return `$${value}`;
        case "":
        case "%":
            return `${value}${unit}`;
        default:
            return `${value} ${unit}`;
    }
};
const _applyOptions = (value, formatOptions) => {
    // eslint-disable-next-line prefer-const
    let [wholePart, decimalPart = ""] = value.split(".");
    if (formatOptions.digits !== undefined) {
        decimalPart = (decimalPart + "0".repeat(formatOptions.digits)).slice(0, formatOptions.digits);
    }
    if (formatOptions.removeTrailingZero) {
        decimalPart = decimalPart.replace(/\.?0+$/, "");
    }
    value = (wholePart || "0") + (decimalPart ? "." + decimalPart : "");
    return value;
};
function formatBN(bn, decimals, formatOptions = { format: Format.hex }) {
    if (formatOptions.format === Format.hex)
        return bn.toHexString();
    const maxBN = formatOptions.max !== undefined && (0, utils_1.parseUnits)(formatOptions.max.toString(), decimals);
    if (maxBN && bn.gt(maxBN)) {
        return `> ${formatBN(maxBN, decimals, formatOptions)}`;
    }
    const minBN = formatOptions.min !== undefined && (0, utils_1.parseUnits)(formatOptions.min.toString(), decimals);
    if (minBN && bn.lt(minBN)) {
        return `< ${formatBN(minBN, decimals, formatOptions)}`;
    }
    let value;
    const isNegative = bn.isNegative();
    switch (formatOptions.format) {
        case Format.commas:
            value = _formatComas(bn.abs(), decimals, formatOptions);
            break;
        case Format.number:
            value = _formatNumber(bn.abs(), decimals, formatOptions);
            break;
        case Format.short:
            value = _formatShort(bn.abs(), decimals, formatOptions);
            break;
        case Format.percent:
            value = _formatNumber(bn.abs().mul(100), decimals, formatOptions);
            break;
    }
    const formattedValue = (isNegative && !/^0\.0+$/.test(value) ? "-" : formatOptions.sign ? "+" : "") + value;
    if (formatOptions.unit) {
        return _withUnit(formattedValue, formatOptions.unit);
    }
    return formattedValue;
}
exports.formatBN = formatBN;
/**
 * returns a string representation of a number, always in a decimal format (avoid the 1.34e-15 format for small numbers)
 * @param number
 */
const safeNumberToString = (number) => {
    const str = number.toString();
    if (!/[eE]/.test(str))
        return str;
    const [a, n] = str.split(/[eE]/);
    if (n[0] === "+") {
        const [whole, decimal = ""] = a.split(".");
        return whole + decimal + "0".repeat(+n - decimal.length);
    }
    if (n[0] === "-") {
        const isNegative = a[0] === "-";
        return ((isNegative ? "-" : "") +
            "0." +
            "0".repeat(-+n - 1) +
            (isNegative ? a.slice(1) : a).split(".").join(""));
    }
    throw new Error(`Unhandled case: ${str}`);
};
exports.safeNumberToString = safeNumberToString;
function formatNumber(number, formatOptions = { format: Format.number }, precision = 18) {
    return formatBN((0, utils_1.parseUnits)((0, exports.safeNumberToString)(number), precision), precision, formatOptions);
}
exports.formatNumber = formatNumber;
